// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `collect_layout_ids`, `find_terminal_size`, `folder_color_to_string`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Get all projects from the cached remote state.
List<ProjectInfo> getProjects({required String connId}) =>
    RustLib.instance.api.crateApiStateGetProjects(connId: connId);

/// Get the focused project ID from the cached remote state.
String? getFocusedProjectId({required String connId}) =>
    RustLib.instance.api.crateApiStateGetFocusedProjectId(connId: connId);

/// Get all folders from the cached remote state.
List<FolderInfo> getFolders({required String connId}) =>
    RustLib.instance.api.crateApiStateGetFolders(connId: connId);

/// Get the project order from the cached remote state.
List<String> getProjectOrder({required String connId}) =>
    RustLib.instance.api.crateApiStateGetProjectOrder(connId: connId);

/// Check if a terminal has unprocessed output (dirty flag).
bool isDirty({required String connId, required String terminalId}) => RustLib
    .instance
    .api
    .crateApiStateIsDirty(connId: connId, terminalId: terminalId);

/// Send a special key (e.g. "Enter", "Tab", "Escape") to a terminal.
///
/// The key name is deserialized from JSON (e.g. `"Enter"`, `"CtrlC"`, `"ArrowUp"`).
Future<void> sendSpecialKey({
  required String connId,
  required String terminalId,
  required String key,
}) => RustLib.instance.api.crateApiStateSendSpecialKey(
  connId: connId,
  terminalId: terminalId,
  key: key,
);

/// Get a project's layout tree as JSON.
///
/// Returns the `ApiLayoutNode` serialized as JSON, or `None` if the project
/// has no layout. Using JSON avoids complex recursive enum FRB codegen.
String? getProjectLayoutJson({
  required String connId,
  required String projectId,
}) => RustLib.instance.api.crateApiStateGetProjectLayoutJson(
  connId: connId,
  projectId: projectId,
);

/// Get all terminal IDs from the cached remote state (flat list).
List<String> getAllTerminalIds({required String connId}) =>
    RustLib.instance.api.crateApiStateGetAllTerminalIds(connId: connId);

/// Get the server-side terminal size from the cached state.
/// Returns (0, 0) if the terminal is not found or size is not available.
ServerTerminalSize getServerTerminalSize({
  required String connId,
  required String terminalId,
}) => RustLib.instance.api.crateApiStateGetServerTerminalSize(
  connId: connId,
  terminalId: terminalId,
);

/// Create a new terminal in a project.
Future<void> createTerminal({
  required String connId,
  required String projectId,
}) => RustLib.instance.api.crateApiStateCreateTerminal(
  connId: connId,
  projectId: projectId,
);

/// Close a terminal in a project.
Future<void> closeTerminal({
  required String connId,
  required String projectId,
  required String terminalId,
}) => RustLib.instance.api.crateApiStateCloseTerminal(
  connId: connId,
  projectId: projectId,
  terminalId: terminalId,
);

/// Focus a terminal in a project.
Future<void> focusTerminal({
  required String connId,
  required String projectId,
  required String terminalId,
}) => RustLib.instance.api.crateApiStateFocusTerminal(
  connId: connId,
  projectId: projectId,
  terminalId: terminalId,
);

/// FFI-friendly folder info.
class FolderInfo {
  final String id;
  final String name;
  final List<String> projectIds;
  final String folderColor;

  const FolderInfo({
    required this.id,
    required this.name,
    required this.projectIds,
    required this.folderColor,
  });

  @override
  int get hashCode =>
      id.hashCode ^ name.hashCode ^ projectIds.hashCode ^ folderColor.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FolderInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          projectIds == other.projectIds &&
          folderColor == other.folderColor;
}

/// Flat FFI-friendly project info.
class ProjectInfo {
  final String id;
  final String name;
  final String path;
  final bool isVisible;
  final List<String> terminalIds;
  final String folderColor;

  const ProjectInfo({
    required this.id,
    required this.name,
    required this.path,
    required this.isVisible,
    required this.terminalIds,
    required this.folderColor,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      path.hashCode ^
      isVisible.hashCode ^
      terminalIds.hashCode ^
      folderColor.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProjectInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          path == other.path &&
          isVisible == other.isVisible &&
          terminalIds == other.terminalIds &&
          folderColor == other.folderColor;
}

/// Server terminal size returned via FFI.
class ServerTerminalSize {
  final int cols;
  final int rows;

  const ServerTerminalSize({required this.cols, required this.rows});

  @override
  int get hashCode => cols.hashCode ^ rows.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServerTerminalSize &&
          runtimeType == other.runtimeType &&
          cols == other.cols &&
          rows == other.rows;
}
