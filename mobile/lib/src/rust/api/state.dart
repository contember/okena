// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `collect_layout_ids_vec`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Get all projects from the cached remote state.
List<ProjectInfo> getProjects({required String connId}) =>
    RustLib.instance.api.crateApiStateGetProjects(connId: connId);

/// Get the focused project ID from the cached remote state.
String? getFocusedProjectId({required String connId}) =>
    RustLib.instance.api.crateApiStateGetFocusedProjectId(connId: connId);

/// Check if a terminal has unprocessed output (dirty flag).
bool isDirty({required String connId, required String terminalId}) => RustLib
    .instance
    .api
    .crateApiStateIsDirty(connId: connId, terminalId: terminalId);

/// Send a special key (e.g. "Enter", "Tab", "Escape") to a terminal.
///
/// The key name is deserialized from JSON (e.g. `"Enter"`, `"CtrlC"`, `"ArrowUp"`).
Future<void> sendSpecialKey({
  required String connId,
  required String terminalId,
  required String key,
}) => RustLib.instance.api.crateApiStateSendSpecialKey(
  connId: connId,
  terminalId: terminalId,
  key: key,
);

/// Get all terminal IDs from the cached remote state (flat list).
List<String> getAllTerminalIds({required String connId}) =>
    RustLib.instance.api.crateApiStateGetAllTerminalIds(connId: connId);

/// Flat FFI-friendly project info.
class ProjectInfo {
  final String id;
  final String name;
  final String path;
  final bool isVisible;
  final List<String> terminalIds;
  final Map<String, String> terminalNames;

  const ProjectInfo({
    required this.id,
    required this.name,
    required this.path,
    required this.isVisible,
    required this.terminalIds,
    required this.terminalNames,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      path.hashCode ^
      isVisible.hashCode ^
      terminalIds.hashCode ^
      terminalNames.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProjectInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          path == other.path &&
          isVisible == other.isVisible &&
          terminalIds == other.terminalIds &&
          terminalNames == other.terminalNames;
}
