// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Get the visible terminal cells for rendering.
List<CellData> getVisibleCells({
  required String connId,
  required String terminalId,
}) => RustLib.instance.api.crateApiTerminalGetVisibleCells(
  connId: connId,
  terminalId: terminalId,
);

/// Get the current cursor state.
CursorState getCursor({required String connId, required String terminalId}) =>
    RustLib.instance.api.crateApiTerminalGetCursor(
      connId: connId,
      terminalId: terminalId,
    );

/// Scroll the terminal display by delta lines (positive = up into history, negative = down).
void scrollTerminal({
  required String connId,
  required String terminalId,
  required int delta,
}) => RustLib.instance.api.crateApiTerminalScrollTerminal(
  connId: connId,
  terminalId: terminalId,
  delta: delta,
);

/// Get the current scroll display offset (0 = at bottom).
int getDisplayOffset({required String connId, required String terminalId}) =>
    RustLib.instance.api.crateApiTerminalGetDisplayOffset(
      connId: connId,
      terminalId: terminalId,
    );

/// Send text input to a terminal.
Future<void> sendText({
  required String connId,
  required String terminalId,
  required String text,
}) => RustLib.instance.api.crateApiTerminalSendText(
  connId: connId,
  terminalId: terminalId,
  text: text,
);

/// Resize a terminal (local + send WS message to server).
Future<void> resizeTerminal({
  required String connId,
  required String terminalId,
  required int cols,
  required int rows,
}) => RustLib.instance.api.crateApiTerminalResizeTerminal(
  connId: connId,
  terminalId: terminalId,
  cols: cols,
  rows: rows,
);

/// Resize only the local alacritty terminal â€” does NOT send a WS resize message to the server.
/// Used when mobile adapts to the server's terminal size.
void resizeLocal({
  required String connId,
  required String terminalId,
  required int cols,
  required int rows,
}) => RustLib.instance.api.crateApiTerminalResizeLocal(
  connId: connId,
  terminalId: terminalId,
  cols: cols,
  rows: rows,
);

/// Cell data for FFI transfer (flat, no pointers).
class CellData {
  /// The character in this cell.
  final String character;

  /// Foreground color as ARGB packed u32.
  final int fg;

  /// Background color as ARGB packed u32.
  final int bg;

  /// Flags: bold(1) | italic(2) | underline(4) | strikethrough(8) | inverse(16) | dim(32).
  final int flags;

  const CellData({
    required this.character,
    required this.fg,
    required this.bg,
    required this.flags,
  });

  @override
  int get hashCode =>
      character.hashCode ^ fg.hashCode ^ bg.hashCode ^ flags.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CellData &&
          runtimeType == other.runtimeType &&
          character == other.character &&
          fg == other.fg &&
          bg == other.bg &&
          flags == other.flags;
}

/// Cursor shape variants.
enum CursorShape { block, underline, beam }

/// Cursor state for FFI transfer.
class CursorState {
  final int col;
  final int row;
  final CursorShape shape;
  final bool visible;

  const CursorState({
    required this.col,
    required this.row,
    required this.shape,
    required this.visible,
  });

  @override
  int get hashCode =>
      col.hashCode ^ row.hashCode ^ shape.hashCode ^ visible.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CursorState &&
          runtimeType == other.runtimeType &&
          col == other.col &&
          row == other.row &&
          shape == other.shape &&
          visible == other.visible;
}
